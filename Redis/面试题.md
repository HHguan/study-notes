# 什么是Redis？它主要用来什么的？ 
Redis，英文全称是Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案
# 说说Redis的基本数据结构类型 
String,List,Set,Hash,ZSet
Geospatial,Hyperloglog,Bitmap
# Redis 的五种基本数据类型
## String SDS简单动态字符串（len free buf[]）
set key value、get key
共享session、分布式锁，计数器、限流
## Hash ziplist(压缩列表) hashtable(哈希表)
hset key field value 、hget key field
缓存用户信息等
## List ziplist(压缩列表) linkedlist(链表)
lpush key value [value ...] 、lrange key start end
消息队列，文章列表,
## Set intset（整数集合）hashtable（哈希表）
sadd key element [element ...]、smembers key
用户标签,生成随机数抽奖、社交需求。
## zset ziplist（压缩列表）、skiplist（跳跃表）
zadd key score member [score member ...]，zrank key member
排行榜，社交需求（如用户点赞）。
## Redis 的三种特殊数据类型
Geo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。
HyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。
Bitmaps ：用一个比特位来映射某个元素的状态，在Redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组
# Redis为什么这么快？
1. 基于内存实现（省去磁盘I/O消耗）
2. 高效的数据结构
SDS优点 获取长度O(1),空间预分配,惰性空间释放,二进制安全（使用len来结束，而不是 \0）
跳表 多级索引的链表 平均O(logN) 最坏O(N)
3. 合理的数据编码
String 数组int 非数字小于39字符 embstr 大于39raw
List 列表的元素个数小于512个，列表每个元素的值都小于64字节使用ziplist否则使用linkedlist
Hash 哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码
Set 如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码
Zset 当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码
4. 合理的线程模型(单线程，避免CPU上下文切换，和加锁)
I/O 多路复用：单个线程处理多个连接，epoll实现，将连接，读写，关闭转为事件，不在网络I/O上浪费时间
IO多路复用其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；而没有文件句柄就绪时,就会阻塞应用程序，交出cpu。
5. 虚拟内存机制(热数据在内存，冷数据在磁盘)
Redis直接自己构建了VM机制 ，不会像一般的系统会调用系统函数处理，会浪费一定的时间去移动和请求。
# 什么是缓存击穿、缓存穿透、缓存雪崩？ 
## 缓存穿透(数据没在缓存中，每次都去查数据库)
解决:
非法请求（参数校验，过滤非法值）
数据库为空（缓存空值，或者默认值，同时设置过期时间）
使用布隆过滤器快速判断数据是否存在（布隆过滤器原理：它由初始值为0的位图数组和N个哈希函数组成。一个对一个key进行N个hash算法获取N个值，在比特数组中将这N个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在）
## 缓存雪奔问题（缓存的数据大量过期或者失效）
解决：设置均匀的过期时间，不在同一个时间点上过期
构建高可用集群
## 缓存击穿问题（指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。）
1.使用互斥锁方案。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。
2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。
# 什么是热Key问题，如何解决热key问题 
访问频率高的key,导致服务器资源不足或者宕机
## 产生原因
读多写少
请求分片集中，超过单Redi服务器的性能，比如固定名称key，Hash落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。
## 识别
校验判断，客户端统计上报，服务代理层上报
## 解决
扩容，增加副本，均衡流量
将热key分散到不同的服务器中；
使用二级缓存，即JVM本地缓存,减少Redis的读请求。
# Redis 过期策略和内存淘汰策略 
过期：定时过期，惰性过期，定期过期（惰性过期和定期过期两种过期策略）
redis采取的是定期过期，每隔100ms就随机抽取一定数量的key来检查和删除的。但是呢，最后可能会有很多已经过期的key没被删除。这时候，redis采用惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且已经过期了，此时就会删除。
内存淘汰策略：
volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；
allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；
volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。
allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；
noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。
总结：默认内存不足报错 设置过期时间(最近最少使用，使用频率，随机) 全部key(最近最少使用，使用频率，随机)
# Redis的常用应用场景
缓存
排行榜（zset）
计数器应用
共享Session
分布式锁 setnx
社交网络
消息队列
位操作
# Redis 的持久化机制有哪些？优缺点说说 
开启AOF优先使用AOF否则使用RDB
RDB:备份内存数据 触发手动（save[阻塞],bgsave[子进程保存非阻塞]）自动触发(save m n m秒数据修改n次 自动触发)
优点 适合大规模的数据恢复场景，如备份，全量复制等
缺点 没办法做到实时持久化/秒级持久化。  新老版本存在RDB格式兼容问题
AOF:保存命令（默认不开启，解决实时性问题）
AOF的优点： 数据的一致性和完整性更高
AOF的缺点： AOF记录的内容越多，文件越大，数据恢复变慢。（重写机制，缩小文件大小）
# 怎么实现Redis的高可用？ 
主从模式，哨兵模式，集群模式
# 使用过Redis分布式锁嘛？有哪些注意点呢？ 
分布式系统数据一致性问题
注意点：一般也是用lua脚本代替。
# 使用过Redisson嘛？说说它的原理 
只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了锁过期释放，业务没执行完问题。
# 什么是Redlock算法 
按顺序向5个master节点请求加锁
根据设置的超时时间来判断，是不是要跳过该master节点。
如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
如果获取锁失败，解锁！
# Redis的跳跃表 （zset底层实现）
跳跃表是有序集合zset的底层实现之一
跳跃表支持平均O（logN）,最坏 O（N）复杂度的节点查找，还可以通过顺序性操作批量处理节点。
跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。
跳跃表就是在链表的基础上，增加多级索引提升查找效率。
# MySQL与Redis 如何保证双写一致性 
缓存延时双删(删缓存，更新数据库，休眠一会在删缓存)
删除缓存重试机制(删缓存，更新数据库，休眠一会在删缓存,删除失败，将key放到消息队列，获取key，重新删除)
读取biglog异步删除缓存（    可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性）
# 为什么Redis 6.0 之后改多线程呢？ 
使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程
这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。
# Redis 事务机制 
Redis通过MULTI、EXEC、WATCH等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

简言之，Redis事务就是顺序性、一次性、排他性的执行一个队列中的一系列命令。
开始事务（MULTI）命令入队执行事务（EXEC）、撤销事务（DISCARD ）
# Redis的Hash 冲突怎么办 
拉链法，扩容rehash
# 在生成 RDB期间，Redis 可以同时处理写请求么？
可用 不过save命令会阻塞，bgsave不会
# Redis底层，使用的什么协议?
RESP，英文全称是Redis Serialization Protocol,它是专门为redis设计的一套序列化协议. 这个协议其实在redis的1.2版本时就已经出现了,但是到了redis2.0才最终成为redis通讯协议的标准。

RESP主要有实现简单、解析速度快、可读性好等优点。
# 布隆过滤器











